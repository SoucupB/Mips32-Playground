(()=>{"use strict";var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Mips32Compiler:()=>Ze});class s{static isNumeric(e){return e>="0"&&e<="9"}static isAlpha(e){return/^[a-zA-Z]$/.test(e)}static isOperator(e){return["+","-","*","/","%","<",">","|","^","&"].includes(e)}static isSeparator(e){return" "==e}static isCommaSeparator(e){return","==e}static isAssignationEnding(e){return";"==e}static pruneSpacesAndNewlines(e,t){for(;t<e.length&&s.isEmptySpaceOrNewLine(e[t]);)t++;return t}static isEmptySpaceOrNewLine(e){return" "==e||"\n"==e||"\t"==e||"\t\n"==e}}const i=s;class r{static isValid(e){return!(!e||!e.length)&&(i.isOperator(e[0])||"=="==e||"!="==e||"||"==e||"&&"==e||"<="==e||">="==e)}static chomp(e,t){if(!e||!e.length)return O.invalid();let s=i.pruneSpacesAndNewlines(e,t);if(e.length-s>=2){let t=["==","!=","||","&&","<=",">="];for(let i=0,n=t.length;i<n;i++)if(`${e[s]}${e[s+1]}`==t[i])return new O(t[i],s+2,r)}return i.isOperator(e[s])?new O(e[s],s+1,r):O.invalid()}static chompEqual(e,t){return t=i.pruneSpacesAndNewlines(e,t),!e||t>=e.length||"="!=e[t]?O.invalid():new O("=",t+1,r)}static chompOpenParanth(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||"("!=e[t]?O.invalid():new O("(",t+1,r)}static chompCloseParanth(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||")"!=e[t]?O.invalid():new O(")",t+1,r)}static chompOpenBracket(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||"{"!=e[t]?O.invalid():new O("{",t+1,r)}static chompCloseBracket(e,t){return(t=i.pruneSpacesAndNewlines(e,t))>=e.length||"}"!=e[t]?O.invalid():new O("}",t+1,r)}}const n=r;class h{static isValid(e){for(let t=0,s=e.length;t<s;t++)if(!i.isNumeric(e[t]))return!1;return!0}static chomp(e,t){if(!e||!e.length)return O.invalid();let s=i.pruneSpacesAndNewlines(e,t),r="";for(;s<e.length&&i.isNumeric(e[s]);)r+=e[s++];return r.length?new O(r,s,h):O.invalid()}}const o=h;class a{static chomp(e,t){let s=l.chomp(e,t);return s.isInvalid()?O.invalid():(s.type=a,s)}}class l{static isValid(e){if(!e.length)return!1;if(i.isNumeric(e[0]))return!1;for(let t=0,s=e.length;t<s;t++)if(!i.isAlpha(e[t])&&!i.isNumeric(e[t])&&"_"!=e[t])return!1;return!0}static isKeyword(e){return!!["auto","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","volatile","while"].includes(e)}static chomp(e,t){if(!e||!e.length||i.isNumeric(e[t]))return O.invalid();let s=i.pruneSpacesAndNewlines(e,t),r="";for(;s<e.length&&(i.isAlpha(e[s])||i.isNumeric(e[s])||"_"==e[s]);)r+=e[s++];return r.length?l.isKeyword(r)?O.invalid():new O(r,s,l):O.invalid()}}class c{static keyWords(){return["int","char"]}}class u{static chomp(e,t){let s=u.chompKeywordsInitialization(e,t);if(s.isInvalid())return O.invalid();if((t=s.index)>=e.length||!i.isSeparator(e[t]))return O.invalid();t++;let r=l.chomp(e,t);if(r.isInvalid())return O.invalid();t=r.index;let n=new O(null,t,u);return n.childrenChomps=[s,r],n}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=c.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new O(s[i],t+s[i].length,c);return O.invalid()}}const d={VARIABLE_NOT_DEFINED:1,VARIABLE_MULTIPLE_DEFINITION:2,METHOD_NOT_DEFINED:3,WRONG_NUMBER_OF_PARAMETERS:4,NO_ERRORS:5,INVALID_RETURN:6,METHOD_MULTIPLE_DEFINITION:7,PREDEFINED_VALUE:8,MISSING_MAIN_METHOD:9,MULTIPLE_MAIN_METHODS:10,PARSE_ERROR:11,AMBIGUOS_DECLARATION:12,INVALID_VOID_EXPRESSION_USE:13};class g{constructor(e,t){this.buffer=e,this.type=t}static clean(){return new g(null,d.NO_ERRORS)}isClean(){return this.type==d.NO_ERRORS}toString(){for(const[e,t]of Object.entries(d))if(t==this.type)return e;return""}}class p{static chomp(e,t,s=!0){let r=p.chompDeclaration(e,t);if(t=r.index,s){if(t=i.pruneSpacesAndNewlines(e,t),!i.isAssignationEnding(e[t]))return O.invalid();r.index++}return r}static chompDeclaration(e,t){let s=p.chompInitializedVariable(e,t);if(s.isInvalid())return O.invalid();t=s.index;let i=$.chomp(e,t);if(i.isInvalid())return s;t=i.index;let r=new O("",t,p,!0);return r.childrenChomps=[s,i],r}static chompDeclarator(e,t){let s=V.chomp(e,t);if(!s.isInvalid())return s;let i=l.chomp(e,t);return i.isInvalid()?O.invalid():i}static chompInitializedVariable(e,t){let s=p.chompDeclarator(e,t);t=s.index;let i=n.chompEqual(e,t);return i.isInvalid()?O.invalid():(t=i.index,s.index=t,s)}static toString(e){let t="";const s=e.childrenChomps[0];switch(s.type){case l:t+=s.buffer;break;case V:t+=`*${s.childrenChomps[0].toString()}`}return t+="=",t+=e.childrenChomps[1].toString(),t+=";",t}static isAssignerDefined(e,t){switch(e.type){case l:return t.isVariableDefined(e.buffer);case V:return $.checkStackInitialization(e.childrenChomps[0],t)}return!1}static findUnassignedVariables(e,t){let s=e.childrenChomps,i=s[0],r=s[1],n=[];if(p.isAssignerDefined(i,t)||n.push(i),n.length)return new g(null,d.VARIABLE_NOT_DEFINED);let h=$.checkStackInitialization(r,t);return h.isClean()?g.clean():h}}class f{static searchChompByType(e,t){let s=[];return f.searchChompByType_t(e,t,s),s}static chompToDictionary(e){const t={};return Object.keys(e).forEach((s=>{t[s]=e[s]})),t}static searchChompByType_t(e,t,s){let i=f.chompToDictionary(e),r=!0;for(const[e,s]of Object.entries(t))if(e in i&&s!=i[e]){r=!1;break}r&&s.push(e);let n=e.childrenChomps;for(let e=0,i=n.length;e<i;e++)f.searchChompByType_t(n[e],t,s)}}class m{static keyWords(){return["int","char"]}}class b{}class R{static isValid(e){let t=0,s=R.chompDeclarationHeader(e,t);if(s.isInvalid())return!1;for(t=s.index;t<e.length;){let s=R.chompDeclaration(e,t);if(s.isInvalid())break;t=s.index,i.isCommaSeparator(e[t])&&t++}return!!i.isAssignationEnding(e[t])}static chomp(e,t){let s=[],r=R.chompDeclarationHeader(e,t);if(r.isInvalid())return O.invalid();for(s.push(r),t=r.index;t<e.length;){let r=R.chompDeclaration(e,t);if(r.isInvalid())break;if(s.push(r),t=r.index,t=i.pruneSpacesAndNewlines(e,t),!i.isCommaSeparator(e[t]))break;t++}if(t=i.pruneSpacesAndNewlines(e,t),!i.isAssignationEnding(e[t]))return O.invalid();let n=new O(null,t+1,R,!0);return n.childrenChomps=s,n}static chompDeclaration(e,t){let s=R.chompInitializedVariable(e,t);if(s.isInvalid())return O.invalid();t=s.index;let i=$.chomp(e,t);if(i.isInvalid()){let e=new O(null,t,b,!0);return e.childrenChomps=[s],e}t=i.index;let r=new O(null,t,b,!0);return r.childrenChomps=[s,i],r}static chompDeclarationHeader(e,t){let s=R.chompKeywordsInitialization(e,t);return s.isInvalid()?s:(t=s.index,i.isSeparator(e[t])?(s.index=t+1,s):O.invalid())}static chompInitializedVariable(e,t){let s=l.chomp(e,t);if(s.isInvalid())return O.invalid();t=s.index;let i=n.chompEqual(e,t);return i.isInvalid()?s:(t=i.index,new O(s.buffer,t,l))}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=m.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new O(s[i],t+s[i].length,m);return O.invalid()}static displayComponent(e){let t="",s=e.childrenChomps;t+=s[0].buffer+"=";for(let e=1,i=s.length;e<i;e++)s[e].type!=$?t+=s[e].buffer:t+=s[e].toString();return t}static display(e){if(e.isInvalid())return"Invalid!";let t=[];t.push(e.childrenChomps[0].buffer);let s=e.childrenChomps;for(let e=1,i=s.length;e<i;e++)t.push(R.displayComponent(s[e]));return t.join(" -> ")}static initializeVariable(e,t){let s=f.searchChompByType(e,{type:l});for(let e=0,i=s.length;e<i;e++)t.push(s[e].buffer)}static hasVariableAlreadyBeenDefined(e,t){let s=f.searchChompByType(e,{type:l});for(let e=0,i=s.length;e<i;e++)if(t.isVariableDefined(s[e].buffer))return!0;return!1}static addToStackAndVerify(e,t){let s=f.searchChompByType(e,{type:b});for(let e=0,i=s.length;e<i;e++){let i=s[e].childrenChomps,r=i[0];if(R.hasVariableAlreadyBeenDefined(r,t))return new g([r.buffer],d.VARIABLE_MULTIPLE_DEFINITION);if(R.initializeVariable(r,t),i.length>1){let e=i[1],s=$.checkStackInitialization(e,t);if(!s.isClean())return s}}return g.clean()}}class I{static keyWords(){return["while","for"]}}class k{static chomp(e,t,s=!1){let i=k.chompKeywordsInitialization(e,t);return i.isInvalid()?O.invalid():(t=i.index,"while"==i.buffer?k.chompWhileBlock(e,t,s):"for"==i.buffer?k.chompForBlock(e,t,s):O.invalid())}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=I.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new O(s[i],t+s[i].length,I);return O.invalid()}static chompWhileBlock(e,t,s){let i=n.chompOpenParanth(e,t);if(i.isInvalid())return O.invalid();t=i.index;let r=$.chomp(e,t);if(r.isInvalid())return O.invalid();t=r.index;let h=n.chompCloseParanth(e,t);if(h.isInvalid())return O.invalid();t=h.index;let o=y.chomp(e,t,s);if(o.isInvalid())return O.invalid();t=o.index;let a=new O("while",t,k);return a.childrenChomps=[r,o],a}static chompForBlock(e,t,s){let r=n.chompOpenParanth(e,t);if(r.isInvalid())return O.invalid();t=r.index;let h=k.chompForInitialization(e,t);if(h.isInvalid())return O.invalid();t=h.index;let o=$.chomp(e,t);if(o.isInvalid())return O.invalid();if((t=o.index)>=e.length||!i.isAssignationEnding(e[t]))return O.invalid();t++;let a=p.chomp(e,t,!1);if(a.isInvalid())return O.invalid();t=a.index;let l=n.chompCloseParanth(e,t);if(l.isInvalid())return O.invalid();t=l.index;let c=y.chomp(e,t,s);if(c.isInvalid())return O.invalid();t=c.index;let u=new O("for",t,k);return u.childrenChomps=[h,o,a,c],u}static chompForInitialization(e,t){let s=[p.chomp,R.chomp];for(let i=0;i<s.length;i++){let r=s[i](e,t);if(!r.isInvalid())return r}return O.invalid()}static addToStackAndVerify_While(e,t){const s=e.childrenChomps;let i=s[0],r=$.checkStackInitialization(i,t);if(!r.isClean())return r;if(s.length<2)return g.clean();let n=s[1];return y.addToStackAndVerify(n,t)}static addToStackAndVerify_For(e,t){const s=e.childrenChomps;let i=s[0],r=s[1],n=s[2];switch(i.type){case p:{let e=p.findUnassignedVariables(i,t);if(!e.isClean())return e;break}case R:{let e=R.addToStackAndVerify(i,t);if(!e.isClean())return e;break}}const h=$.checkStackInitialization(r,t);if(!h.isClean())return h;const o=$.checkStackInitialization(n,t);if(!o.isClean())return o;if(s.length<=3)return g.clean();const a=s[3];return y.addToStackAndVerify(a,t)}static addToStackAndVerify(e,t){switch(e.buffer){case"while":return k.addToStackAndVerify_While(e,t);case"for":{t.freeze();let s=k.addToStackAndVerify_For(e,t);return t.pop(),s}}return g.clean()}}class S{static keyWords(){return["if"]}}class v{static chomp(e,t,s=!1){let i=v.chompKeywordsInitialization(e,t);if(i.isInvalid())return O.invalid();t=i.index;let r=n.chompOpenParanth(e,t);if(r.isInvalid())return O.invalid();t=r.index;let h=$.chomp(e,t);if(h.isInvalid())return O.invalid();t=h.index;let o=n.chompCloseParanth(e,t);if(o.isInvalid())return O.invalid();t=o.index;let a=y.chomp(e,t,s);if(a.isInvalid())return O.invalid();t=a.index;let l=new O(null,t,v);return l.childrenChomps=[h,a],l}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=S.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new O(s[i],t+s[i].length,S);return O.invalid()}static addToStackAndVerify(e,t){let s=e.childrenChomps;const i=s[0],r=s[1];let n=$.checkStackInitialization(i,t);return n.isClean()?y.addToStackAndVerify(r,t):n}}class y{static chomp(e,t,s=!1){let i=n.chompOpenBracket(e,t);if(i.isInvalid())return O.invalid();t=i.index;let r=y.chompBlock(e,t,s);t=r.index;let h=n.chompCloseBracket(e,t);if(h.isInvalid())return O.invalid();t=h.index;let o=new O(null,t,y);return o.childrenChomps=r.childrenChomps,o}static expressionChompWithLineTerminator(e,t){let s=$.chomp(e,t);return s.isInvalid()||(t=s.index)>=e.index||!i.isAssignationEnding(e[t])?O.invalid():(s.index++,s)}static chompBlock(e,t,s){let i=[p.chomp,R.chomp,(e,t)=>y.chomp(e,t,s),(e,t)=>k.chomp(e,t,s),(e,t)=>v.chomp(e,t,s)];s&&i.push(E.chomp),i.push(y.expressionChompWithLineTerminator);let r=[];for(;t<e.length;){let s=!1;for(let n=0;n<i.length;n++){let h=i[n](e,t);if(!h.isInvalid()){t=h.index,s=!0,r.push(h);break}}if(!s)break}let n=new O(null,t,y);return n.childrenChomps=r,n}static addToStackAndVerify_t(e,t){let s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){let i=s[e];switch(i.type){case p:{let e=p.findUnassignedVariables(i,t);if(!e.isClean())return e;break}case R:{let e=R.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case y:{let e=y.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case k:{let e=k.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case v:{let e=v.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case _:{let e=E.addToStackAndVerify(i,t);if(!e.isClean())return e;break}case $:{let e=$.checkStackInitialization(i,t);if(!e.isClean())return e;break}}}return g.clean()}static addToStackAndVerify(e,t){t.freeze();let s=y.addToStackAndVerify_t(e,t);return t.pop(),s}}class T{static keyWords(){return["int","void","char"]}}class A{static findUnassignedVariables(e,t){let s=e.childrenChomps[1].childrenChomps;for(let e=0,i=s.length;e<i;e++){let i=$.checkStackInitialization(s[e],t);if(!i.isClean())return i}return g.clean()}static doesMethodHaveAllTheParametersPresent(e,t){let s=e.childrenChomps,i=s[0].buffer,r=s[1].childrenChomps;const n=t.getArgsFromMethodName(i);return!n||n.length!=r.length}}class w{}class _{}class C{}class E{static keyWords(){return["return"]}static chompReturnWithExpression(e,t){let s=$.chomp(e,t);if(s.isInvalid())return O.invalid();if(t=s.index,(t=i.pruneSpacesAndNewlines(e,t))>=e.length||!i.isAssignationEnding(e[t]))return O.invalid();t++;let r=new O(null,t,_);return r.childrenChomps=[s],r}static chompReturnWithoutExpression(e,t){if((t=i.pruneSpacesAndNewlines(e,t))>=e.length||!i.isAssignationEnding(e[t]))return O.invalid();t++;let s=new O(null,t,C);return s.childrenChomps=[],s}static chomp(e,t,s=!0){let r=E.chompKeywordsInitialization(e,t);if(r.isInvalid())return O.invalid();if((t=r.index)>=e.length||!i.isSeparator(e[t]))return O.invalid();t++;const n=E.chompReturnWithExpression(e,t);if(!n.isInvalid())return n;const h=E.chompReturnWithoutExpression(e,t);return h.isInvalid()?O.invalid():h}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=E.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new O(s[i],t+s[i].length,T);return O.invalid()}static addToStackAndVerify(e,t){const s=e.childrenChomps[0];return $.checkStackInitialization(s,t)}}class N{static chompDeclaration(e,t){let s=N.methodHeaderDeclaration(e,t);if(s.isInvalid())return O.invalid();t=s.index;let i=n.chompOpenParanth(e,t);if(i.isInvalid())return O.invalid();t=i.index;let r=N.chompMethodDeclarationsAnthetParams(e,t);if(r.isInvalid())return O.invalid();t=r.index;let h=n.chompCloseParanth(e,t);if(h.isInvalid())return O.invalid();t=h.index;let o=y.chomp(e,t,!0);if(o.isInvalid())return O.invalid();t=o.index;let a=new O(s.buffer,t,N);return a.childrenChomps=[s,r,o],a}static chompMethodCall(e,t){let s=a.chomp(e,t);if(s.isInvalid())return O.invalid();t=s.index;let i=n.chompOpenParanth(e,t);if(i.isInvalid())return O.invalid();t=i.index;let r=N.chompMethodParameters(e,t);if(r.isInvalid())return O.invalid();t=r.index;let h=n.chompCloseParanth(e,t);if(h.isInvalid())return O.invalid();t=h.index;let o=new O(null,t,A);return o.childrenChomps=[s,r],o}static chompKeywordsInitialization(e,t){t=i.pruneSpacesAndNewlines(e,t);let s=T.keyWords();for(let i=0,r=s.length;i<r;i++)if(e.indexOf(s[i],t)==t)return new O(s[i],t+s[i].length,T);return O.invalid()}static chompMethodParameters(e,t){let s=[],r=!1;for(;t<e.length;){let n=$.chomp(e,t),h=n.isInvalid();if(!r&&h)return N.arrayToChomp(s,t);if(h)return O.invalid();if(r=!0,t=n.index,s.push(n),(t=i.pruneSpacesAndNewlines(e,t))>=e.length||!i.isCommaSeparator(e[t]))return N.arrayToChomp(s,t);t++}return N.arrayToChomp(s,t)}static methodHeaderDeclaration(e,t){let s=N.chompKeywordsInitialization(e,t);if(s.isInvalid())return O.invalid();if((t=s.index)>=e.length||!i.isSeparator(e[t]))return O.invalid();t++;let r=a.chomp(e,t);if(r.isInvalid())return O.invalid();t=r.index;let n=new O(r.buffer,t,w);return n.childrenChomps=[s,r],n}static methodName(e){return e.type!=N?null:e.childrenChomps[0].buffer}static arrayToChomp(e,t){let s=new O(null,t);return s.childrenChomps=e,s}static chompMethodDeclarationsAnthetParams(e,t){let s=[],r=!1;for(;t<e.length;){let n=u.chomp(e,t);if(!r&&n.isInvalid())return N.arrayToChomp(s,t);if(s.push(n),r=!0,(t=n.index)>=e.length||!i.isCommaSeparator(e[t]))return N.arrayToChomp(s,t);t++}return N.arrayToChomp(s,t)}static searchMethodByName(e,t){return f.searchChompByType(e,{buffer:t,type:N})}static searchAllMethods(e){return f.searchChompByType(e,{type:N})}static pushMethodParams(e,t,s){const i=t.childrenChomps;let r=[];for(let e=0,t=i.length;e<t;e++){const t=i[e].childrenChomps[0],s=i[e].childrenChomps[1];r.push({type:t,name:s})}s.pushMethod(e,r)}static checkParamsAndPush(e,t){const s=e.childrenChomps;let i=[];for(let e=0,r=s.length;e<r;e++){const r=s[e].childrenChomps[1].buffer;t.isVariableDefined(r)&&i.push(r)}return i}static pushParams(e,t){const s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){const i=s[e].childrenChomps[1];t.push(i.buffer)}}static doesReturnNeedsToBeNonVoid(e){const t=f.searchChompByType(e,{type:_}),s=f.searchChompByType(e,{type:C});return!(!t.length||s.length)}static doesReturnNeedsToBeVoid(e){return!f.searchChompByType(e,{type:_}).length}static doesReturnNeedsToBe(e,t){return"void"==e?N.doesReturnNeedsToBeVoid(t):"void"==e||N.doesReturnNeedsToBeNonVoid(t)}static isMethodVoid(e){let t=e.childrenChomps[0];return"void"==f.searchChompByType(t,{type:T})[0].buffer}static addDefaultReturn(e){e.childrenChomps[2].childrenChomps.push(new O(null,0,C))}static addDefaultReturnsForVoidMethods(e){let t=f.searchChompByType(e,{type:N});for(let e=0,s=t.length;e<s;e++)"main"!=t[e].buffer&&N.isMethodVoid(t[e])&&N.addDefaultReturn(t[e])}static addToStackAndVerify(e,t){let s=e.childrenChomps;const i=s[0],r=s[1],n=s[2],h=i.childrenChomps[1],o=i.childrenChomps[0].buffer;if(t.isMethodDefined(h.buffer)||t.isVariableDefined(h.buffer))return new g([h.buffer],d.VARIABLE_MULTIPLE_DEFINITION);let a=N.checkParamsAndPush(r,t);if(a.length)return new g(a,d.VARIABLE_MULTIPLE_DEFINITION);if(!N.doesReturnNeedsToBe(o,n))return new g(null,d.INVALID_RETURN);N.pushMethodParams(h.buffer,r,t),t.freeze(),N.pushParams(r,t);let l=y.addToStackAndVerify(n,t);return l.isClean()?(t.pop(),g.clean()):l}}class D{static isValid(e){let t=[0],s=[];if(D.denominator_Chomp(e,t,s).isInvalid())return!1;for(;t<e.length;){if(D.operator_Chomp(e,t,s).isInvalid())return!1;if(D.denominator_Chomp(e,t,s).isInvalid())return!1}return!0}static operator_Chomp(e,t,s){let i=n.chomp(e,t[0]);return i.isInvalid()?O.invalid():(s.push(i),t[0]=i.index,i)}static denominator_Chomp(e,t,s){let i=D.chompDenominator(e,t[0]);if(i.isInvalid()){let i=[t[0]],r=D.chomp_ParanthesisData(e,i[0]);return r.isInvalid()||(s.push(r),t[0]=r.index),r}return s.push(i),t[0]=i.index,i}static chompFromArray(e,t){let s=new O(null,t[0],D,!0);return s.childrenChomps=e,s}static chompSearch_t(e,t){let s=[t],i=[];if(D.denominator_Chomp(e,s,i).isInvalid())return O.invalid();for(;s<e.length;){if(D.operator_Chomp(e,s,i).isInvalid())return D.chompFromArray(i,s);if(D.denominator_Chomp(e,s,i).isInvalid())return O.invalid()}return D.chompFromArray(i,s)}static chomp(e,t){for(let s=e.length-1;s>=t;s--){let i=D.chompSearch_t(e.substring(t,s+1),0);if(!i.isInvalid())return i.index+=t,i}return O.invalid()}static chomp_ParanthesisData(e,t){let s=n.chompOpenParanth(e,t);if(s.isInvalid())return O.invalid();t=s.index;let i=D.chompSearch_t(e,t);if(i.isInvalid())return O.invalid();t=i.index;let r=n.chompCloseParanth(e,t);return r.isInvalid()?O.invalid():(t=r.index,D.chompFromArray(i.childrenChomps,[t]))}static chompDenominator(e,t){let s=[N.chompMethodCall,V.chomp,o.chomp,l.chomp];for(let i=0,r=s.length;i<r;i++){let r=s[i](e,t);if(!r.isInvalid())return r}return O.invalid()}static checkStackInitialization_t(e,t){const s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++)switch(s[e].type){case l:if(!t.isVariableDefined(s[e].buffer))return new g([s[e].buffer],d.VARIABLE_NOT_DEFINED);break;case V:{let i=V.findUnassignedVariables(s[e],t);if(!i.isClean())return i;break}case D:D.checkStackInitialization_t(s[e],t);break;case A:{let i=A.findUnassignedVariables(s[e],t);if(!i.isClean())return i;if(A.doesMethodHaveAllTheParametersPresent(s[e],t))return new g("Wrong number of arguments of method!",d.WRONG_NUMBER_OF_PARAMETERS);break}}return g.clean()}static checkStackInitialization(e,t){return D.checkStackInitialization_t(e,t)}}const $=D;class V{static chomp(e,t){if(!e||t>=e.length)return O.invalid();if("*"!=e[t=i.pruneSpacesAndNewlines(e,t)])return O.invalid();t++;let s=l.chomp(e,t);if(!s.isInvalid()){t=s.index;let e=new O(null,t,V);return e.childrenChomps=[$.chomp(s.buffer,0)],e}let r=$.chomp_ParanthesisData(e,t);if(r.isInvalid())return O.invalid();t=r.index;let n=new O(null,t,V);return n.childrenChomps=[r],n}static findUnassignedVariables(e,t){const s=e.childrenChomps[0];return $.checkStackInitialization(s,t)}}let M=0;class x{constructor(e,t,s=null,i=!1,r=!1){this.buffer=e,this.index=t,this.invalid=r,this.type=s,this.childrenChomps=[],this.isParent=i,this.parentChomp=null,this.id=M++,this.ignore=!1,this.expressionTree=null}static invalid(){return new x(-1,-1,null,!1,!0)}pushChild(e){this.childrenChomps.push(e)}isInvalid(){return this.invalid}toString(e=0){if(this.isParent){let t="";for(let s=0,i=this.childrenChomps.length;s<i;s++){t+=this.childrenChomps[s].toString(e+1)}return e?`(${t})`:t}return this.type===V?`*${this.childrenChomps[0].toString()}`:this.buffer}}const O=x;class B{constructor(){this.index=[0],this.variables=[],this.methods=[]}push(e){this.variables.push({type:"variable",value:e})}pushMethod(e,t){this.methods.push({type:"method",value:e,params:t})}getArgsFromMethodName(e){for(let t=0,s=this.methods.length;t<s;t++)if("method"==this.methods[t].type&&e==this.methods[t].value)return this.methods[t].params;return null}isMethodDefined(e){for(let t=0,s=this.methods.length;t<s;t++)if("method"==this.methods[t].type&&e==this.methods[t].value)return!0;return!1}isVariableDefined(e){for(let t=0,s=this.variables.length;t<s;t++)if("variable"==this.variables[t].type&&e==this.variables[t].value)return!0;return!1}top(){return this.variables[this.variables.length-1].value}freeze(){this.index.push(this.variables.length)}pop(){if(this.index.length){for(let e=this.variables.length-1;e>=this.index[this.index.length-1];e--)this.variables.pop();this.index.pop()}}}class P{static methods(e){return`${P.getElementAt()}${P.storeElement()}${P.storePrint(e)}${P.bytePrint(e)}`}static getElementAt(){return"int getElement(int buffer,int pos){return *(buffer+pos*4);}"}static storeElement(){return"int setElement(int buffer,int pos,int element){*(buffer+pos*4)=element;return 0;}"}static bytePrint(e){return`\n    int __digitCount(int n) {\n      int total = 0;\n      while(n) {\n        n = n / 10;\n        total = total + 1;\n      }\n\n      return total;\n    }\n\n    int pushCharacter(int character) {\n      int stdoutBuffer = ${e};\n      int currentOffset = *(stdoutBuffer - 4);\n      *(stdoutBuffer + currentOffset) = character;\n      *(stdoutBuffer - 4) = currentOffset + 1;\n      return 0;\n    }\n    \n    int printNumber_t(int element){\n      if(element == 0) {\n        return 0;\n      }\n      printNumber_t(element / 10);\n      pushCharacter(element % 10 + 48);\n      return 0;\n    }\n\n    int printChar(int element){\n      return pushCharacter(element);\n    }\n    \n    int printNumber(int element){\n      if(element < 0) {\n        element = 0 - element;\n        printChar(45);\n        return printNumber_t(element);\n      }\n      if(element == 0) {\n        printChar(48);\n      }\n      return printNumber_t(element);\n    }\n    `}static storePrint(e){return`int printLine(int element){int startingPointer=${e};int size=*(startingPointer-4);*(startingPointer+size)=element;*(startingPointer-4)=size+4;return 0;}`}}class z{constructor(e,t=[],s=!0,i=65536){this.code=s?`${P.methods(i)}${e}`:e,this.errors=t}fillParents(e){for(let t=0,s=e.childrenChomps.length;t<s;t++)e.childrenChomps[t].parentChomp=e,this.fillParents(e.childrenChomps[t])}chomp(){let e=this._chomp(this.code,0);return this.fillParents(e),e.isInvalid()?(this.errors.push(new g(null,d.PARSE_ERROR)),O.invalid()):this.validateChomp(e)?(this.ignoreUnusedMethods(e),e):O.invalid()}validateChomp(e){let t=N.searchMethodByName(e,"main");return t.length?t.length>1?(this.errors.push(new g(null,d.MULTIPLE_MAIN_METHODS)),!1):!!this.validateMethodsUniqueness(e)&&(!!this.validateVariableNonKeywords(e)&&(!!this.validateStackVariables(e)&&(this.validateMethodNoVariables(e)?!!this.validateVoidMethodsInExpressions(e)||(this.errors.push(new g(null,d.INVALID_VOID_EXPRESSION_USE)),!1):(this.errors.push(new g(null,d.AMBIGUOS_DECLARATION)),!1)))):(this.errors.push(new g(null,d.MISSING_MAIN_METHOD)),!1)}pairVoidMethods(e){let t={},s=f.searchChompByType(e,{type:N});for(let e=0,i=s.length;e<i;e++)"main"!=s[e].buffer&&N.isMethodVoid(s[e])&&(t[s[e].buffer]=1);return t}doesExpressionHaveMethod(e,t){let s=f.searchChompByType(e,{type:A});for(let e=0,i=s.length;e<i;e++){if(s[e].childrenChomps[0].buffer in t)return!0}return!1}doesNodeHaveMethod(e,t){let s=f.searchChompByType(e,{type:$});for(let e=0,i=s.length;e<i;e++)if(this.doesExpressionHaveMethod(s[e],t))return!0;return!1}doMethodHasVoidCalls(e,t){let s=f.searchChompByType(e,{type:A});for(let e=0,i=s.length;e<i;e++){if(s[e].childrenChomps[0].buffer in t)return!0}return!1}expressionsVoidMethods(e,t){let s=f.searchChompByType(e,{type:A});for(let e=0,i=s.length;e<i;e++){if(s[e].childrenChomps[0].buffer in t&&s[e].parentChomp.childrenChomps.length>1||this.doMethodHasVoidCalls(s[e].childrenChomps[1],t))return!1}return!0}validateVoidMethodsInExpressions(e){let t=this.pairVoidMethods(e),s=f.searchChompByType(e,{type:R});for(let e=0,i=s.length;e<i;e++)if(this.doesNodeHaveMethod(s[e],t))return!1;let i=f.searchChompByType(e,{type:p});for(let e=0,s=i.length;e<s;e++)if(this.doesNodeHaveMethod(i[e],t))return!1;return!!this.expressionsVoidMethods(e,t)}validateVariableNonKeywords(e){let t=f.searchChompByType(e,{type:l});const s=["auto","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","volatile","while"];for(let e=0,i=t.length;e<i;e++)if(s.includes(t[e].buffer))return this.errors.push(new g(t[e].buffer,d.PREDEFINED_VALUE)),!1;return!0}ignoreUnusedMethods_t(e,t,s){const i=t[e];let r=f.searchChompByType(i,{type:A});for(let e=0,i=r.length;e<i;e++){const i=r[e].childrenChomps[0].buffer;i in s||(s[i]=1,this.ignoreUnusedMethods_t(i,t,s))}}pairMethodsWithNames(e){let t={},s=f.searchChompByType(e,{type:N});for(let e=0,i=s.length;e<i;e++)t[N.methodName(s[e])]=s[e];return t}ignoreUnusedMethods(e){let t=this.pairMethodsWithNames(e),s={main:1};this.ignoreUnusedMethods_t("main",t,s);for(const[e,i]of Object.entries(t))e in s||(i.ignore=!0)}compilationError(){return 0==this.errors.length}errorsToString(){let e=[];for(let t=0,s=this.errors.length;t<s;t++)e.push(this.errors[t].toString());return e.join(", ")}validateMethodsUniqueness(e){let t=N.searchAllMethods(e),s={};for(let e=0,i=t.length;e<i;e++)if(t[e].buffer in s||(s[t[e].buffer]=0),s[t[e].buffer]++,s[t[e].buffer]>1)return this.errors.push(new g(t[e].buffer,d.METHOD_MULTIPLE_DEFINITION)),!1;return!0}validateMethodNoVariables(e){let t=N.searchAllMethods(e),s=f.searchChompByType(e,{type:l}),i={};for(let e=0,t=s.length;e<t;e++)i[s[e].buffer]=1;for(let e=0,s=t.length;e<s;e++)if(t[e].buffer in i)return!1;return!0}validateStackVariables(e){return this.validateStackVariables_t(e,new B)}validateStackVariables_t(e,t){let s=e.childrenChomps;for(let e=0,i=s.length;e<i;e++){const i=s[e];switch(i.type){case p:{const e=p.findUnassignedVariables(i,t);if(!e.isClean())return this.errors.push(e),!1;break}case R:{const e=R.addToStackAndVerify(i,t);if(!e.isClean())return this.errors.push(e),!1;break}case N:{const e=N.addToStackAndVerify(i,t);if(!e.isClean())return this.errors.push(e),!1;break}}}return!0}_chomp(e,t){let s=[N.chompDeclaration],r=[];for(;t<e.length;){let i=!1;for(let n=0,h=s.length;n<h;n++){let h=s[n](e,t);if(!h.isInvalid()){r.push(h),i=!0,t=h.index;break}}if(!i)break}if((t=i.pruneSpacesAndNewlines(e,t))<e.length)return O.invalid();let n=new O(null,t,z);return n.childrenChomps=r,N.addDefaultReturnsForVoidMethods(n),n}}const L=1,G=2;let F=65536;class U{constructor(e){this.instructionArray=e,this.register={},this.initialStackPointer=524288,this.stackPointer=this.initialStackPointer,this.memory=new Array(1048576).fill(0),this.addresses={},this.outputBuffer="",this.pc=0,this.instructionCounter={},this.saveLabelAddresses()}getStdoutResponse(){let e=[];for(let t=0,s=this.getNumberAtAddress(this.memory,65532);t<s;t+=4)e.push(this.getNumberAtAddress(this.memory,F+t));return e.join("\n")}getRawStdoutBuffer(){const e=this.getNumberAtAddress(this.memory,65532);let t="";for(let s=0;s<e;s++)t+=String.fromCharCode(this.memory[s+F]);return t}get32BitNumberAtAddress(e){return this.getNumberAtAddress(this.memory,e)}saveRegValue(e,t){let s=t.toString(),i=e.toString();s in this.register&&(this.register[i]=this.register[s])}saveLabelAddresses(){for(let e=0,t=this.instructionArray.length;e<t;e++){const t=this.instructionArray[e];t instanceof ue&&(this.addresses[t.label]=e)}}currentStackPointer(){return this.stackPointer}getRegValue(e){const t=e.toString();return t in this.register?parseInt(this.register[t]):0}printPointerBytes(e){let t=[];for(let s=0;s<e;s++)t.push(this.memory[this.stackPointer+s]);return t.join(" ")}positiveNumberToByteArray(e){const t=[0,0,0,0];return t[0]=255&e,t[1]=e>>8&255,t[2]=e>>16&255,t[3]=e>>24&255,t}negativeNumberToByteArray(e){const t=2**32+e;return this.positiveNumberToByteArray(t)}numberToByteArray(e){return e>=0?this.positiveNumberToByteArray(e):this.negativeNumberToByteArray(e)}saveRegInStack(e,t){let s=this.numberToByteArray(this.getRegValue(t)),i=parseInt(e);for(let e=0,t=s.length;e<t;e++)this.memory[this.stackPointer-i+e]=s[e]}saveRegInMem(e,t){let s=this.numberToByteArray(this.getRegValue(t)),i=parseInt(e);for(let e=0,t=s.length;e<t;e++)this.memory[i+e]=s[e]}get32ByteInteger(e){return e<2**31?e:-(2**32-e)}getNumberAtAddress(e,t,s=L){switch(s){case L:{let s=0,i=1;for(let r=0;r<4;r++)s+=e[t+r]*i,i*=256;return this.get32ByteInteger(s)}case G:return e[t]}return 0}saveMemInReg(e,t){this.register[t.toString()]=this.getNumberAtAddress(this.memory,parseInt(e))}saveStackInReg(e,t){this.register[t]=this.getNumberAtAddress(this.memory,this.stackPointer-parseInt(e))}saveRegMemInReg(e,t){this.register[t.toString()]=this.getNumberAtAddress(this.memory,parseInt(this.register[e.toString()]))}saveRegInMemReg(e,t){let s=this.numberToByteArray(this.getRegValue(e)),i=this.getRegValue(t);for(let e=0,t=s.length;e<t;e++)this.memory[i+e]=s[e]}numberFromPointer(e){return this.getNumberAtAddress(this.memory,e)}runMov(e){switch(e.type){case K.REG_TO_REG:this.saveRegValue(e.dst,e.src);break;case K.REG_TO_STACK:this.saveRegInStack(e.dst,e.src);break;case K.NUMBER_TO_REG:this.register[e.dst.toString()]=parseInt(e.src);break;case K.REG_TO_MEM:this.saveRegInMem(e.dst,e.src);break;case K.MEM_TO_REG:this.saveMemInReg(e.src,e.dst);break;case K.STACK_TO_REG:this.saveStackInReg(e.src,e.dst);break;case K.REG_MEM_TO_REG:this.saveRegMemInReg(e.src,e.dst);break;case K.REG_TO_MEM_REG:this.saveRegInMemReg(e.src,e.dst)}}runPush(e){this.saveRegInStack(0,e.register),this.stackPointer+=4}runPop(e){this.stackPointer-=parseInt(e.bytes)}jumpAtRegisterLabel(e){this.pc=this.getRegValue(e)-1}runJump(e){switch(e.type){case de.LABEL:this.pc=this.addresses[e.value];break;case de.REGISTER:this.jumpAtRegisterLabel(e.value)}}runAdd(e){this.register[e.dst.toString()]=this.getRegValue(e.b)+this.getRegValue(e.c)}runMul(e){this.register[e.dst.toString()]=this.getRegValue(e.b)*this.getRegValue(e.c)}runSub(e){this.register[e.dst.toString()]=this.getRegValue(e.b)-this.getRegValue(e.c)}runMul(e){this.register[e.dst.toString()]=this.getRegValue(e.b)*this.getRegValue(e.c)}runDivAndMod(e){this.register.HI=this.getRegValue(e.a)%this.getRegValue(e.b),this.register.LO=Math.floor(this.getRegValue(e.a)/this.getRegValue(e.b))}runPrp(e){this.register[e.reg.toString()]=this.pc+e.offset}booleanToNumber(e){return e?1:0}runCmp(e){this.register._setGe=this.booleanToNumber(this.getRegValue(e.regA)>=this.getRegValue(e.regB)),this.register._setE=this.booleanToNumber(this.getRegValue(e.regA)==this.getRegValue(e.regB)),this.register._setNe=this.booleanToNumber(this.getRegValue(e.regA)!=this.getRegValue(e.regB)),this.register._setLe=this.booleanToNumber(this.getRegValue(e.regA)<=this.getRegValue(e.regB)),this.register._setNz=this.booleanToNumber(this.getRegValue(e.regA)&&this.getRegValue(e.regB)),this.register.CF=this.booleanToNumber(this.getRegValue(e.regA)<this.getRegValue(e.regB)),this.register.CT=this.booleanToNumber(this.getRegValue(e.regA)>this.getRegValue(e.regB))}setGe(e){this.register[e.regA.toString()]=this.register._setGe}setE(e){this.register[e.regA.toString()]=this.register._setE}setNe(e){this.register[e.regA.toString()]=this.register._setNe}setNz(e){this.register[e.regA.toString()]=this.register._setNz}setLe(e){this.register[e.regA.toString()]=this.register._setLe}setTest(e){this.register.zero_reg=this.booleanToNumber(this.getRegValue(e.regA)&&this.getRegValue(e.regB))}setJz(e){"zero_reg"in this.register&&!this.register.zero_reg&&(this.pc=this.addresses[e.label])}setOr(e){this.register.or_reg=this.booleanToNumber(this.getRegValue(e.regA)||this.getRegValue(e.regB))}setDor(e){this.register[e.reg.toString()]=this.register.or_reg}setPrint(e){switch(e.type){case me.REGISTER:this.outputBuffer+=this.getRegValue(e.value);break;case me.MEMORY:this.outputBuffer+=this.numberFromPointer(parseInt(e.value)+this.initialStackPointer)}}addInstructionToStatistics(e){const t=e.constructor.name;t in this.instructionCounter||(this.instructionCounter[t]=0),this.instructionCounter[t]++}runInstruction(e){e instanceof J&&this.runMov(e),e instanceof Z&&this.runPush(e),e instanceof te&&this.runPop(e),e instanceof ge&&this.runJump(e),e instanceof q&&this.runAdd(e),e instanceof pe&&this.runDivAndMod(e),e instanceof X&&this.runSub(e),e instanceof Y&&this.runMul(e),e instanceof fe&&this.runPrp(e),e instanceof se&&this.runCmp(e),e instanceof ae&&this.setGe(e),e instanceof re&&this.setE(e),e instanceof ie&&this.setNe(e),e instanceof he&&this.setNz(e),e instanceof le&&this.setLe(e),e instanceof ne&&this.setTest(e),e instanceof ce&&this.setJz(e),e instanceof be&&this.setPrint(e),e instanceof oe&&this.setOr(e),e instanceof j&&this.setDor(e)}getOutputBuffer(){return this.outputBuffer}statistics(){let e=0,t=[];for(const[t,s]of Object.entries(this.instructionCounter))e+=s;for(const[s,i]of Object.entries(this.instructionCounter))e&&t.push(`${s}: ${i/e*100}`);return t.join("\n")}run(){for(this.pc=0;this.pc<this.instructionArray.length;this.pc++)this.runInstruction(this.instructionArray[this.pc])}}class W{constructor(){this.block=[],this.runner=null}toString_t(e){return e instanceof W?this.toStringArray_t(e.block):[e.toString()]}getStdoutResponse(){return this.runner.getStdoutResponse()}getRawStdoutBuffer(){return this.runner.getRawStdoutBuffer()}toStringArray_t(e){let t=[];for(let s=0,i=e.length;s<i;s++){let i=this.toString_t(e[s]);for(let e=0,s=i.length;e<s;e++)t.push(i[e])}return t}toStringArray(){return this.toStringArray_t(this.block)}toString(){return this.toStringArray_t(this.block).join("\n")}push(e){this.block.push(e)}flatten_t(e,t){if(e instanceof W)for(let s=0,i=e.block.length;s<i;s++)this.flatten_t(e.block[s],t);else t.push(e)}flatten(){let e=new W;return this.flatten_t(this,e),e}getRegValue(e){return this.runner.getRegValue(e)}getOutputBuffer(){return this.runner.getOutputBuffer()}getPopback(e,t){let s=0;for(;e<t.length&&t[e]instanceof te;)s+=parseInt(t[e].bytes),e++;return s}markPopBacks(e,t,s){for(;e<s.length&&s[e]instanceof te;)t[e]=1,e++}removeUselessPushPopBlocks(e){let t=new W,s=new Array(e.length).fill(0);for(let i=0,r=e.length;i<r;i++)s[i]||(e[i]instanceof te?t.push(new te(this.getPopback(i,e))):t.push(e[i])),this.markPopBacks(i,s,e);return t}removeComplementaryPushPopBlocks(e){let t=new W,s=new Array(e.length).fill(0);for(let t=0,i=e.length-1;t<i;t++)e[t]instanceof Z&&e[t+1]instanceof te&&4==parseInt(e[t+1].bytes)?(s[t]=1,s[t+1]=1):e[t]instanceof Z&&e[t+1]instanceof te&&(s[t]=1,e[t+1].bytes=parseInt(e[t+1].bytes)-4);for(let i=0,r=e.length;i<r;i++)s[i]||t.push(e[i]);return t}optimize(){this.block=this.flatten().block;let e=this.removeUselessPushPopBlocks(this.block).block;this.block=this.removeComplementaryPushPopBlocks(e).block}run(){this.runner=new U(this.flatten().block),this.runner.run()}}class H{toString(){return"UNDEFINED REGISTER"}}const K={MEM_TO_REG:1,REG_TO_REG:2,REG_TO_MEM:3,NUMBER_TO_REG:4,STACK_TO_REG:5,REG_TO_STACK:6,REG_MEM_TO_REG:7,REG_TO_MEM_REG:8};class j extends H{constructor(e){super(),this.reg=e}toString(){return`SETDOR $${this.reg}`}}class J extends H{constructor(e,t,s){super(),this.dst=e,this.src=t,this.type=s}toString(){switch(this.type){case K.NUMBER_TO_REG:return`MOV $${this.dst} ${this.src}`;case K.REG_TO_REG:return`MOV $${this.dst} $${this.src}`;case K.MEM_TO_REG:return`MOV $${this.dst} [${this.src}]`;case K.STACK_TO_REG:return 0==this.src?`MOV $${this.dst} [$st]`:`MOV $${this.dst} [$st-${this.src}]`;case K.REG_MEM_TO_REG:return`MOV $${this.dst} [$${this.src}]`;case K.REG_TO_MEM_REG:return`MOV [$${this.dst}] $${this.src}`;case K.REG_TO_STACK:return 0==this.dst?`MOV [$st] $${this.src}`:`MOV [$st-${this.dst}] $${this.src}`}}}class q extends H{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`ADD $${this.dst} $${this.b} $${this.c}`}}class X extends H{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`SUB $${this.dst} $${this.b} $${this.c}`}}class Y extends H{constructor(e,t,s){super(),this.dst=e,this.b=t,this.c=s}toString(){return`MUL $${this.dst} $${this.b} $${this.c}`}}class Z extends H{constructor(e){super(),this.register=e}toString(){return`PUSH $${this.register}`}}const Q=1,ee=2;class te extends H{constructor(e,t=Q){super(),this.bytes=e,this.type=t}toString(){switch(this.type){case Q:return`POP ${this.bytes}`;case ee:return`POP $${this.bytes}`}return""}}class se extends H{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`CMP $${this.regA} $${this.regB}`}}class ie extends H{constructor(e){super(),this.regA=e}toString(){return`SETNE $${this.regA}`}}class re extends H{constructor(e){super(),this.regA=e}toString(){return`SETE $${this.regA}`}}class ne extends H{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`TEST $${this.regA} $${this.regB}`}}class he extends H{constructor(e){super(),this.regA=e}toString(){return`SETNZ $${this.regA}`}}class oe extends H{constructor(e,t){super(),this.regA=e,this.regB=t}toString(){return`OR $${this.regA} $${this.regB}`}}class ae extends H{constructor(e){super(),this.regA=e}toString(){return`SETGE $${this.regA}`}}class le extends H{constructor(e){super(),this.regA=e}toString(){return`SETLE $${this.regA}`}}class ce extends H{constructor(e){super(),this.label=e}toString(){return`JZ ${this.label}`}}class ue extends H{constructor(e){super(),this.label=e}toString(){return`:${this.label}`}}const de={LABEL:1,REGISTER:2};class ge extends H{constructor(e,t=de.LABEL){super(),this.value=e,this.type=t}toString(){switch(this.type){case de.LABEL:return`JMP ${this.value}`;case de.REGISTER:return`JMP $${this.value}`}}}class pe extends H{constructor(e,t){super(),this.a=e,this.b=t}toString(){return`DIV $${this.a} $${this.b}`}}class fe extends H{constructor(e,t){super(),this.reg=e,this.offset=t}toString(){return`PRP $${this.reg} ${this.offset}`}}const me={MEMORY:1,REGISTER:2};class be extends H{constructor(e,t=me.REGISTER){super(),this.value=e,this.type=t}toString(){switch(this.type){case me.REGISTER:return`PRR $${this.value} 4`;case me.MEMORY:return`PRR [${this.value}] 4`}}}let Re=0;class Ie{constructor(e){this.chomp=e,this.left=null,this.right=null,this.nodeID="expr-node-"+Re++,this.register=null}}const ke=1,Se=2;class ve{constructor(e){this.expressionChomp=e,this.root=null,this.precedence=[["&&","||"],["==","!=","<=",">=","<",">"],["^","&","|","<<",">>"],["+","-"],["*","/","%"]],this.returnType=ke}toString_t(e){if(!e.left&&!e.right)return e.chomp.buffer;let t=this.toString_t(e.left),s=this.toString_t(e.right);return`(${t+e.chomp.buffer+s})`}toString(){return this.toString_t(this.root)}createNode(e,t,s){let i=new Ie(s);return i.left=e,i.right=t,i}isNodeVariable(e){return e.chomp.type==l}isNodeMethodCall(e){return!(!e||!e.chomp)&&e.chomp.type==A}getExpressionRegister(e){return e.expressionTree.root.register}getRegister(e){return this.root.register}getNodeMethodCallRegisterResponse(e,t,s,i){const r=e.chomp.childrenChomps,n=r[0],h=r[1].childrenChomps,o=Date.now();s.freeze();for(let e=0,r=h.length;e<r;e++){const r=h[e];r.expressionTree.addInstructionToBlockWithOrder(t,i,s);const n=this.getExpressionRegister(r);t.push(new Z(n)),i.freeRegister(n),s.push(`${o}_${e}`,4)}return s.push(`return_address_offset_${o}`,4),t.push(new fe("ret",3)),t.push(new Z("ret")),t.push(new ge(`_${n.buffer}`)),t.push(new te(s.getFreezeTopDiff())),s.pop(),t.push(new Z("rsp")),s.push(e.nodeID,4),"rsp"}getNodeValue(e,t,s,i){if(this.isNodeMethodCall(e))return this.getNodeMethodCallRegisterResponse(e,t,s,i);return this.isNodeVariable(e)?s.getStackOffset(e.chomp.buffer):e.chomp.buffer}getNodeMovType(e){if(this.isNodeMethodCall(e))return K.REG_TO_REG;return this.isNodeVariable(e)?K.STACK_TO_REG:K.NUMBER_TO_REG}findRegisterForNode(e,t){const s=t.isNodeIDUsed(e.nodeID);if(null!=s)return s;const i=t.findUnusedRegister();return t.saveRegisterID(i,e.nodeID),e.register=i,i}isLeaf(e){return!e.left&&!e.right}pushNonPointerNode(e,t,s,i){let r=this.findRegisterForNode(e,s);return t.push(new J(r,this.getNodeValue(e,t,i,s),this.getNodeMovType(e))),r}pushPointerNode(e,t,s,i){const r=e.chomp.childrenChomps[0];r.expressionTree.addInstructionToBlockWithOrder(t,s,i);let n=this.findRegisterForNode(e,s);const h=r.expressionTree.getRegister(s);return t.push(new J(n,h,K.REG_MEM_TO_REG)),n!=h&&s.freeRegister(h),n}pushLeafNode(e,t,s,i){return e.chomp.type===V?this.pushPointerNode(e,t,s,i):this.pushNonPointerNode(e,t,s,i)}pushMov(e,t,s,i){if(this.isLeaf(e))return this.pushLeafNode(e,t,s,i);let r=this.findRegisterForNode(e,s);return t.push(new J(r,i.getStackOffset(e.nodeID),K.STACK_TO_REG)),r}movAndGetFreeRegisters(e,t,s,i){let r=[null,null],n=[e.left,e.right];for(let e=0;e<n.length;e++){const h=n[e];this.isNodeMethodCall(h)&&(this.getNodeMethodCallRegisterResponse(h,t,i,s),r[e]=this.findRegisterForNode(h,s))}for(let e=0,h=r.length;e<h;e++)null==r[e]?r[e]=this.pushMov(n[e],t,s,i):t.push(new J(r[e],i.getStackOffset(n[e].nodeID),K.STACK_TO_REG));return r}freeRegisters(e,t){for(let s=0,i=e.length;s<i;s++)t.freeRegister(e[s])}addNodeToTheStack(e,t,s,i,r){s.push(new Z(t)),i.push(e.nodeID,4),this.freeRegisters([t],r)}add_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new q(h,r,n)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}sub_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new X(h,r,n)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}mul_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new Y(h,r,n)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}div_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new pe(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new J(h,"LO",K.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}reminder_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new pe(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new J(h,"HI",K.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}equal_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new re(h)),this.addNodeToTheStack(e,h,t,i,s)}setGe_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new ae(h)),this.addNodeToTheStack(e,h,t,i,s)}setLe_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new le(h)),this.addNodeToTheStack(e,h,t,i,s)}notEqual_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new ie(h)),this.addNodeToTheStack(e,h,t,i,s)}less_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new J(h,"CF",K.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}more_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new J(h,"CT",K.REG_TO_REG)),this.addNodeToTheStack(e,h,t,i,s)}doubleAnd_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i);t.push(new se(r,n)),this.freeRegisters([r,n],s);let h=this.findRegisterForNode(e,s);t.push(new he(h)),this.addNodeToTheStack(e,h,t,i,s)}doubleOr_InstructionSet(e,t,s,i){let[r,n]=this.movAndGetFreeRegisters(e,t,s,i),h=this.findRegisterForNode(e,s);t.push(new oe(r,n)),t.push(new j(h)),this.addNodeToTheStack(e,h,t,i,s),this.freeRegisters([r,n],s)}addInstructions(e,t,s,i){switch(e.chomp.buffer){case"+":this.add_InstructionSet(e,t,s,i);break;case"-":this.sub_InstructionSet(e,t,s,i);break;case"*":this.mul_InstructionSet(e,t,s,i);break;case"==":this.equal_InstructionSet(e,t,s,i);break;case"<":this.less_InstructionSet(e,t,s,i);break;case">":this.more_InstructionSet(e,t,s,i);break;case"!=":this.notEqual_InstructionSet(e,t,s,i);break;case"&&":this.doubleAnd_InstructionSet(e,t,s,i);break;case"||":this.doubleOr_InstructionSet(e,t,s,i);break;case">=":this.setGe_InstructionSet(e,t,s,i);break;case"<=":this.setLe_InstructionSet(e,t,s,i);break;case"/":this.div_InstructionSet(e,t,s,i);break;case"%":this.reminder_InstructionSet(e,t,s,i)}}addInstructionToBlock_t(e,t,s,i){(e.left||e.right)&&(this.addInstructionToBlock_t(e.left,t,s,i),this.addInstructionToBlock_t(e.right,t,s,i),this.addInstructions(e,t,s,i))}addInstructionToBlock(e,t,s){if(this.root.left||this.root.right)this.addInstructionToBlock_t(this.root,e,t,s);else{let i=this.findRegisterForNode(this.root,t);e.push(new J(i,this.getNodeValue(this.root,e,s,t),this.getNodeMovType(this.root)))}}expressionRoot(e){let t=new ve(e);return t.build(),t.root}isOperationLeaf(e){return!this.isLeaf(e)&&(this.isLeaf(e.left)&&this.isLeaf(e.right))}numberOfOperations(e){return e?this.numberOfOperations(e.left)+this.numberOfOperations(e.right)+1:0}isVisited(e,t){return e.nodeID in t}order_t(e,t,s){if(!this.isVisited(e,t)&&!this.isLeaf(e)){if(this.isOperationLeaf(e))return s.push(e.left),s.push(e.right),s.push(e),t[e.left.nodeID]=1,t[e.right.nodeID]=1,void(t[e.nodeID]=1);if(this.isVisited(e.left,t)&&this.isVisited(e.right,t))return t[e.nodeID]=1,void s.push(e);if(this.isVisited(e.left,t)&&this.isLeaf(e.right))return t[e.nodeID]=1,t[e.right.nodeID]=1,s.push(e.right),void s.push(e);if(this.isVisited(e.right,t)&&this.isLeaf(e.left))return t[e.nodeID]=1,t[e.left.nodeID]=1,s.push(e.left),void s.push(e);this.order_t(e.left,t,s),this.order_t(e.right,t,s)}}order(){let e={},t=[],s=this.numberOfOperations(this.root);const i=this.root;if(this.isLeaf(i))return[i];for(;t.length<s;)this.order_t(i,e,t);return t}addResultToStack(e,t,s){if(this.returnType==Se){const i=this.getRegister(t);e.push(new Z(i)),s.push(this.root.nodeID,4),this.freeRegisters([i],t)}}pushLastNode(e,t,s){this.pushMov(this.root,e,t,s);let i=this.findRegisterForNode(this.root,t);e.push(new Z(i)),s.push(this.root.nodeID,4),e.push(new te(s.getFreezeTopDiff())),s.pop(),this.addResultToStack(e,t,s),this.freeRegisters([i],t)}addInstructionToBlockWithOrder(e,t,s,i=ke){if(s.freeze(),this.returnType=i,!this.root.left&&!this.root.right)return void this.pushLastNode(e,t,s);const r=this.order();for(let i=0,n=r.length;i<n;i++)this.addInstructions(r[i],e,t,s);e.push(new te(s.getFreezeTopDiff())),s.pop(),this.addResultToStack(e,t,s)}build_t(e=0,t){let s=this.expressionChomp.childrenChomps;if(e>=this.precedence.length)return s[t[0]].type==$?this.expressionRoot(s[t[0]]):new Ie(s[t[0]]);let i=this.build_t(e+1,t);for(;t[0]+1<s.length;){const r=s[t[0]+1];let n=!1;for(let s=0,h=this.precedence[e].length;s<h;s++)if(this.precedence[e][s]==r.buffer){t[0]+=2;const s=this.build_t(e+1,t);i=this.createNode(i,s,r),n=!0}if(!n)break}return i}build(){this.root=this.build_t(0,[0])}}class ye{constructor(){this.registerToID={},this.maxRegisters=32,this.IDToRegisters={}}findUnusedRegister(){for(let e=0;e<this.maxRegisters;e++)if(!(e in this.registerToID))return e;return null}getUsedRegisters(){let e=[];for(const[t,s]of Object.entries(this.registerToID))e.push(t);return e}registerFromID(e){return this.IDToRegisters[e]}isNodeIDUsed(e){return e in this.IDToRegisters?this.IDToRegisters[e]:null}saveRegisterID(e,t){this.registerToID[e]=t,this.IDToRegisters[t]=e}getRegisterFromID(e){return this.registerWithNodeID[e]}freeRegister(e){this.registerToID[e]in this.IDToRegisters&&delete this.IDToRegisters[this.registerToID[e]],e in this.registerToID&&delete this.registerToID[e]}}class Te{constructor(){this.stackValues=[],this.offset={},this.stackOffset=[],this.freezeHistory=[0],this.variableNames=[],this.freezeChunks=[0],this.methodFreezeChunk=0}getStackLastIndex(){return this.stackOffset.length?this.stackOffset[this.stackOffset.length-1]:0}push(e,t){this.offset[e]={stack_offset:this.getStackLastIndex(),size:t},this.stackOffset.push(this.getStackLastIndex()+t),this.variableNames.push(e)}freezeMethodPointer(){this.methodFreezeChunk=this.getStackLastIndex()}freeze(){this.freezeChunks.push(this.stackOffset.length),this.freezeHistory.push(this.getStackLastIndex())}topVariableName(){return this.variableNames.length?this.variableNames[this.variableNames.length-1]:null}pop(){if(this.freezeHistory.length){for(let e=this.stackOffset.length-1;e>=this.freezeChunks[this.freezeChunks.length-1];e--){this.stackOffset.pop();const e=this.topVariableName();delete this.offset[e],this.variableNames.pop()}this.freezeHistory.pop(),this.freezeChunks.pop()}}getFreezeTopDiff(){return this.freezeHistory.length?this.getStackLastIndex()-this.freezeHistory[this.freezeHistory.length-1]:this.getStackLastIndex()}getFreezeTopDiffFromMethod(){return this.getStackLastIndex()-this.methodFreezeChunk}getStackOffset(e){return e in this.offset?this.getStackLastIndex()-this.offset[e].stack_offset:null}}class Ae{constructor(e){this.ast=e,this.registerMem=new ye,this.registerStack=new Te,this.globalStack=new Te,this.labelID=0,this.assignationID=0}buildExpressionTrees(e){let t=f.searchChompByType(e,{type:$});for(let e=0,s=t.length;e<s;e++){let s=new ve(t[e]);t[e].expressionTree||(s.build(),t[e].expressionTree=s)}}createExpressionAsm(e,t,s=ke){e.expressionTree.addInstructionToBlockWithOrder(t,this.registerMem,this.registerStack,s)}saveExpressionResult(e,t){const s=e.expressionTree.root.register;t.push(new Z(s)),this.registerMem.freeRegister(s)}loadVariableInStack(e,t,s){this.createExpressionAsm(e,s);const i=this.getExpressionRegister(e),r=this.registerStack.getStackOffset(t.buffer);s.push(new J(r,i,K.REG_TO_STACK)),this.registerMem.freeRegister(i)}getExpressionStackPoint(e){return this.registerStack.getStackOffset(e.expressionTree.root.nodeID)}loadPointerInStack(e,t,s){this.registerStack.freeze(),this.createExpressionAsm(e,s,Se),this.createExpressionAsm(t,s,Se);let i=this.registerMem.findUnusedRegister();this.registerMem.saveRegisterID(i,"assignation-id-"+this.assignationID++);let r=this.registerMem.findUnusedRegister();this.registerMem.saveRegisterID(r,"assignation-id-"+this.assignationID++),s.push(new J(r,this.getExpressionStackPoint(t),K.STACK_TO_REG)),s.push(new J(i,this.getExpressionStackPoint(e),K.STACK_TO_REG)),s.push(new J(r,i,K.REG_TO_MEM_REG)),s.push(new te(this.registerStack.getFreezeTopDiff())),this.registerMem.freeRegister(i),this.registerMem.freeRegister(r),this.registerStack.pop()}loadExpressionOnStack(e,t,s){if(t.type===V)this.loadPointerInStack(e,t.childrenChomps[0],s);else this.loadVariableInStack(e,t,s)}compileInitialization(e,t=this.registerStack){const s=e.childrenChomps;let i=new W;for(let e=1,t=s.length;e<t;e++){const t=s[e],r=t.childrenChomps[0],n=t.childrenChomps[1];this.createExpressionAsm(n,i),this.registerStack.push(r.buffer,4),this.saveExpressionResult(n,i)}return i}compileAssignation(e){const t=e.childrenChomps;let s=new W;const i=t[1],r=t[0];return this.loadExpressionOnStack(i,r,s),s}popStackValues(e){const t=this.registerStack.getFreezeTopDiff();t&&e.push(new te(t))}getExpressionRegister(e){return e.expressionTree.root.register}nextLabel(){return this.labelID++}compileWhile(e){let t=new W;const s=e.childrenChomps;let i=s[0],r=s[1];const n=`_label${this.nextLabel()}`;t.push(new ue(n)),this.createExpressionAsm(i,t);const h=this.getExpressionRegister(i),o=`_label${this.nextLabel()}`;return t.push(new ne(h,h)),this.registerMem.freeRegister(h),t.push(new ce(o)),t.push(this.compileBlock(r)),t.push(new ge(n)),t.push(new ue(o)),t}compileFor(e){let t=new W;const s=e.childrenChomps;let i=s[0],r=s[1],n=s[2],h=s[3];switch(this.registerStack.freeze(),t.push(new ue(`_startForLoop${this.nextLabel()}`)),i.type){case R:t.push(this.compileInitialization(i));break;case p:t.push(this.compileAssignation(i))}const o=`_label${this.nextLabel()}`;t.push(new ue(o)),this.createExpressionAsm(r,t);const a=this.getExpressionRegister(r),l=`_label${this.nextLabel()}`;return t.push(new ne(a,a)),this.registerMem.freeRegister(a),t.push(new ce(l)),t.push(this.compileBlock(h)),t.push(this.compileAssignation(n)),t.push(new ge(o)),t.push(new ue(l)),t.push(new te(this.registerStack.getFreezeTopDiff())),this.registerStack.pop(),t}compileLoop(e){switch(e.buffer){case"while":return this.compileWhile(e);case"for":return this.compileFor(e)}return new W}popReturnStackPointer(e){const t=this.registerStack.getFreezeTopDiffFromMethod();t&&e.push(new te(t))}compileReturnNonVoidMethod(e){const t=e.childrenChomps[0];let s=new W;this.createExpressionAsm(t,s);const i=this.getExpressionRegister(t);return s.push(new J("ret",this.registerStack.getStackOffset("return_address"),K.STACK_TO_REG)),s.push(new J("rsp",i,K.REG_TO_REG)),this.popReturnStackPointer(s),s.push(new ge("ret",de.REGISTER)),this.registerMem.freeRegister(i),s}compileReturnVoidMethod(e){let t=new W;return t.push(new J("ret",this.registerStack.getStackOffset("return_address"),K.STACK_TO_REG)),this.popReturnStackPointer(t),t.push(new ge("ret",de.REGISTER)),t}compileConditionalBlock(e){let t=new W;const s=e.childrenChomps,i=s[0],r=s[1];this.createExpressionAsm(i,t);const n=this.getExpressionRegister(i),h=`_label${this.nextLabel()}`;return t.push(new ne(n,n)),this.registerMem.freeRegister(n),t.push(new ce(h)),t.push(this.compileBlock(r)),t.push(new ue(h)),t}compileExpression(e){let t=new W;return this.createExpressionAsm(e,t),t}compileBlock(e,t=!0){let s=new W;this.buildExpressionTrees(e);const i=e.childrenChomps;this.registerStack.freeze();for(let e=0,t=i.length;e<t;e++){const t=i[e];switch(t.type){case p:s.push(this.compileAssignation(t));break;case R:s.push(this.compileInitialization(t));break;case y:s.push(this.compileBlock(t));break;case k:s.push(this.compileLoop(t));break;case _:s.push(this.compileReturnNonVoidMethod(t));break;case C:s.push(this.compileReturnVoidMethod(t));break;case v:s.push(this.compileConditionalBlock(t));break;case $:s.push(this.compileExpression(t))}}return t&&this.popStackValues(s),this.registerStack.pop(),s}isMethodMain(e){return"main"==e.buffer}compileMainMethod(e,t){let s=new W;const i=`_${e}`;return s.push(new ue(i)),s.push(this.compileBlock(t)),s}compileMethods(e){const t=e.childrenChomps;let s=new W;const i=t[0],r=t[1].childrenChomps,n=t[2],h=i.childrenChomps[1];if(this.isMethodMain(h))return this.compileMainMethod(h.buffer,n);const o=`_${h}`;s.push(new ue(o)),this.registerStack.freeze();for(let e=0;e<r.length;e++){const t=r[e].childrenChomps[1];this.registerStack.push(t.buffer,4)}return this.registerStack.push("return_address",4),this.registerStack.freezeMethodPointer(),s.push(this.compileBlock(n,!1)),this.registerStack.pop(),s}compileProgram(e,t=!0){let s=e.childrenChomps;this.buildExpressionTrees(e);let i=new W;i.push(new ge("_main"));for(let e=0,t=s.length;e<t;e++){const t=s[e];if(t.type===N)t.ignore||i.push(this.compileMethods(t))}return t&&i.optimize(),i}}const we=1,_e=2;class Ce{constructor(e,t={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},s=1048576){this.block=e,this.stackPointerRegister=t.stackPointerRegister,this.stddoutRegister=t.stddoutRegister,this.memorySize=s,this.hi=t.hi,this.lo=t.lo,this.registerData=t,this.memory=new Array(this.memorySize).fill(0),this.register=new Array(40).fill(0),this.pc=0}getRawStdoutBuffer(){let e=this.registerValue(this.stddoutRegister);const t=this.getNumberAtAddress(this.memory,e-4);let s="";for(let i=0;i<t;i++)s+=String.fromCharCode(this.memory[i+e]);return s}getStackPointer(){return this.registerValue(this.stddoutRegister)}registerValue(e){return this.register[parseInt(e)]}printPointerBytes(e,t){let s=[];for(let i=0;i<e;i++)s.push(this.memory[t+i]);return s}printStack(e){let t=[],s=this.registerValue(this.stackPointerRegister);for(let i=0;i<e;i++)t.push(this.memory[s+i]);return t.join(" ")}unsigned(e){return e>=0?e:2**32- -(e+1)}positiveNumberToByteArray(e){const t=[0,0,0,0];return t[0]=255&e,t[1]=e>>8&255,t[2]=e>>16&255,t[3]=e>>24&255,t}negativeNumberToByteArray(e){const t=2**32+e;return this.positiveNumberToByteArray(t)}numberToByteArray(e){return e>=0?this.positiveNumberToByteArray(e):this.negativeNumberToByteArray(e)}saveRegInMemory(e,t,s){let i=this.numberToByteArray(this.registerValue(t));for(let t=0,r=i.length;t<r;t++)this.memory[e+t+s]=i[t]}get32ByteInteger(e){return e<2**31?e:-(2**32-e)}getNumberAtAddress(e,t,s=we){switch(s){case we:{let s=0,i=1;for(let r=0;r<4;r++)s+=e[t+r]*i,i*=256;return this.get32ByteInteger(s)}case _e:return e[t]}return 0}saveNumberInReg(e,t,s){let i=this.getNumberAtAddress(this.memory,e+s);this.register[parseInt(t)]=i}runInstruction(e){e instanceof De&&(this.register[parseInt(e.dst)]=this.registerValue(e.srcA)+this.registerValue(e.srcB)),e instanceof Oe&&(this.register[parseInt(e.d)]=this.registerValue(e.s)-this.registerValue(e.t)),e instanceof ze&&(this.register[parseInt(e.d)]=this.registerValue(e.s)|this.registerValue(e.t)),e instanceof Fe&&(this.register[parseInt(e.d)]=this.registerValue(e.s)&this.registerValue(e.t)),e instanceof Ve&&(this.register[this.lo]=Math.floor(this.registerValue(e.s)/this.registerValue(e.t)),this.register[this.hi]=this.registerValue(e.s)%this.registerValue(e.t)),e instanceof qe&&(this.pc=parseInt(e.register)),e instanceof Ke&&this.registerValue(e.s)==this.registerValue(e.t)&&(this.pc+=parseInt(e.label)),e instanceof $e&&(this.register[parseInt(e.t)]=this.registerValue(e.s)+parseInt(e.immediate)),e instanceof We&&(this.pc=this.registerValue(e.register)),e instanceof Me&&(this.register[this.lo]=this.registerValue(e.s)*this.registerValue(e.t)),e instanceof He&&(this.register[parseInt(e.d)]=this.booleanToNumber(this.registerValue(e.s)<this.registerValue(e.t))),e instanceof Ye&&(this.register[parseInt(e.d)]=this.booleanToNumber(this.unsigned(this.registerValue(e.s))<this.unsigned(this.registerValue(e.t)))),e instanceof Le&&(this.register[parseInt(e.d)]=this.registerValue(e.s)^this.registerValue(e.t)),e instanceof Ge&&(this.register[parseInt(e.d)]=this.registerValue(e.s)^parseInt(e.i)),e instanceof Be&&this.saveRegInMemory(this.registerValue(e.s),e.t,parseInt(e.i)),e instanceof Pe&&this.saveNumberInReg(this.registerValue(e.s),e.t,parseInt(e.i)),e instanceof Ue&&(this.register[parseInt(e.d)]=this.registerValue(e.s)&parseInt(e.i)),e instanceof xe&&(this.register[parseInt(e.s)]=this.registerValue(e.t)<<parseInt(e.i))}booleanToNumber(e){return e?1:0}run(){for(this.pc=0;this.pc<this.block.length;this.pc++)this.runInstruction(this.block[this.pc])}}class Ee{constructor(e,t,s,i=!0,r={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},n=1048576){this.registerBlock=e.flatten(),this.registerBlock.optimize(),this.stddout=t,this.stackPointer=s,this.block=[],this.memorySize=n,this.registerData=r,this.registerCount=32,this.usedRegisters={HI:this.registerData.hi,LO:this.registerData.lo,rsp:this.registerData.rsp,ret:this.registerData.ret},this.labelsOffsets={},i&&(this.prepareHeader(),this.iterateBlock(),this.iterateImediates(),this.createLabelOffsets())}iterateImediates(){let e=[];for(let t=0,s=this.block.length;t<s;t++)this.block[t]instanceof $e?this.addNumberToBlock(this.block[t],e):e.push(this.block[t]);this.block=e}getStdoutResponse(){let e=[];for(let t=0,s=this.runner.getNumberAtAddress(this.runner.memory,this.stddout-4);t<s;t+=4)e.push(this.getNumberAtAddress(this.runner.memory,this.stddout+t));return e.join("\n")}addLabelFromImmediate(e,t){if(this.doesNumberFitInImmediate(e.register))return void t.push(e);let s=parseInt(e.register),i=65535&s,r=s>>16;t.push(new $e(this.registerData.bitSplitterRegister,this.registerData.zeroReg,i)),t.push(new $e(this.registerData.freeRegister,this.registerData.zeroReg,r)),t.push(new xe(this.registerData.freeRegister,this.registerData.freeRegister,16)),t.push(new ze(this.registerData.freeRegister,this.registerData.freeRegister,this.registerData.bitSplitterRegister)),t.push(new We(this.registerData.freeRegister))}rebuildJumpInstructions(){let e=[];for(let t=0,s=this.block.length;t<s;t++)this.block[t]instanceof qe?this.addLabelFromImmediate(this.block[t],e):e.push(this.block[t]);this.block=e}createLabelOffsets(){for(let e=0,t=this.block.length;e<t;e++)this.block[e]instanceof Je&&(this.labelsOffsets[this.block[e].label]=e,this.block[e]=new je);for(let e=0,t=this.block.length;e<t;e++)this.block[e]instanceof qe&&(this.block[e]=new qe(this.labelsOffsets[this.block[e].register])),this.block[e]instanceof Ke&&(this.block[e].label=this.labelsOffsets[this.block[e].label]-e),this.block[e]instanceof Xe&&(this.block[e]=new $e(this.getRegisterValue(this.block[e].reg),this.registerData.zeroReg,e+this.block[e].offset))}numberToUnsignedRpresentation(e){return e>=0?e:2**32-e+1}doesNumberFitInImmediate(e){return parseInt(e)<65536}iterateBlock(){const e=this.registerBlock.block;for(let t=0,s=e.length;t<s;t++){const s=e[t];s instanceof J&&this.addMoveBlock(s,e,t),s instanceof Z&&this.addPushBlock(s),s instanceof q&&this.addAddInstruction(s),s instanceof te&&this.addPopInstruction(s),s instanceof Y&&this.addMultInstruction(s),s instanceof pe&&this.addDivInstruction(s),s instanceof ge&&this.addJumpInstruction(s),s instanceof ue&&this.block.push(new Je(s.label)),s instanceof se||(s instanceof ie&&this.addSetneInstruction(s,e,t),s instanceof re&&this.addSeteInstruction(s,e,t),s instanceof ae&&this.addSetgeInstruction(s,e,t),s instanceof le&&this.addSetleInstruction(s,e,t),s instanceof he&&this.addSetnzInstruction(s,e,t),s instanceof j&&this.addSetdorInstruction(s,e,t),s instanceof X&&this.addSubInstruction(s),s instanceof ne&&this.addSetTestInstruction(s,e,t),s instanceof ce&&this.addJzInstruction(s),s instanceof fe&&this.addPrpInstruction(s))}}addPrpInstruction(e){this.block.push(new Xe(e.reg,e.offset))}addJzInstruction(e){this.block.push(new Ke(this.registerData.testRegister,this.registerData.zeroReg,e.label))}addSetTestOnEqual(e){this.block.push(new Ye(this.registerData.testRegister,this.registerData.zeroReg,e.regA))}addSetTestInstruction(e){e.regA!=e.regB?(this.block.push(new He(e.regA,this.registerData.zeroReg,e.regA)),this.block.push(new He(e.regB,this.registerData.zeroReg,e.regB)),this.block.push(new Fe(this.registerData.testRegister,e.regA,e.regB))):this.addSetTestOnEqual(e)}addSubInstruction(e){this.block.push(new Oe(e.dst,e.b,e.c))}addSetdorInstruction(e,t,s){let i=this.searchClosestOr(t,s);this.block.push(new Ye(i.regA,this.registerData.zeroReg,i.regA)),this.block.push(new Ye(i.regB,this.registerData.zeroReg,i.regB)),this.block.push(new ze(e.reg,i.regA,i.regB))}addSetnzInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Ye(i.regA,this.registerData.zeroReg,i.regA)),this.block.push(new Ye(i.regB,this.registerData.zeroReg,i.regB)),this.block.push(new Fe(e.regA,i.regA,i.regB))}addSetleInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new He(e.regA,i.regB,i.regA)),this.block.push(new Ge(e.regA,e.regA,1))}addSetgeInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new He(e.regA,i.regA,i.regB)),this.block.push(new Ge(e.regA,e.regA,1))}addSeteInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Le(i.regA,i.regA,i.regB)),this.block.push(new Ye(e.regA,this.registerData.zeroReg,i.regA)),this.block.push(new Ge(e.regA,e.regA,1))}addSetneInstruction(e,t,s){let i=this.searchClosestCmp(t,s);this.block.push(new Le(i.regA,i.regA,i.regB)),this.block.push(new Ye(e.regA,this.registerData.zeroReg,i.regA))}addJumpInstruction(e){switch(e.type){case de.REGISTER:this.block.push(new We(this.getRegisterValue(e.value)));break;case de.LABEL:this.block.push(new qe(e.value))}}getRegisterValue(e){return e in this.usedRegisters?this.usedRegisters[e]:e}addDivInstruction(e){this.block.push(new Ve(e.a,e.b))}addMultInstruction(e){this.block.push(new Me(e.b,e.c)),this.block.push(new $e(e.dst,this.registerData.lo,0))}addPushBlock(e){this.block.push(new Be(this.getRegisterValue(e.register),0,this.registerData.stackPointerRegister)),this.block.push(new $e(this.registerData.stackPointerRegister,this.registerData.stackPointerRegister,4))}addAddInstruction(e){this.block.push(new De(e.dst,e.b,e.c))}addPopInstruction(e){this.block.push(new $e(this.registerData.freeRegister,this.registerData.zeroReg,e.bytes)),this.block.push(new Oe(this.registerData.stackPointerRegister,this.registerData.stackPointerRegister,this.registerData.freeRegister))}searchClosestCmp(e,t){for(let s=t;s>=0;s--)if(e[s]instanceof se)return e[s];return null}searchClosestOr(e,t){for(let s=t;s>=0;s--)if(e[s]instanceof oe)return e[s];return null}addSpecialMov(e,t,s){let i=this.searchClosestCmp(t,s);"CF"!=e.src?"CT"!=e.src?this.block.push(new De(this.getRegisterValue(e.dst),this.getRegisterValue(e.src),this.registerData.zeroReg)):this.block.push(new He(e.dst,i.regB,i.regA)):this.block.push(new He(e.dst,i.regA,i.regB))}addNumberToBlock(e,t){let s=e.t;if(this.doesNumberFitInImmediate(e.immediate))return void t.push(e);let i=parseInt(e.immediate),r=65535&i,n=i>>16;t.push(new $e(this.registerData.bitSplitterRegister,this.registerData.zeroReg,r)),t.push(new $e(s,this.registerData.zeroReg,n)),t.push(new xe(s,s,16)),t.push(new ze(s,s,this.registerData.bitSplitterRegister))}getPositiveLwInstructions(e,t,s){return t>=0?new Pe(e,t,s):(this.block.push(new $e(this.registerData.freeRegister,this.registerData.zeroReg,-t)),this.block.push(new Oe(this.registerData.freeRegister,s,this.registerData.freeRegister)),new Pe(e,0,this.registerData.freeRegister))}getPositiveSwInstructions(e,t,s){return t>=0?new Be(e,t,s):(this.block.push(new $e(this.registerData.freeRegister,this.registerData.zeroReg,-t)),this.block.push(new Oe(this.registerData.freeRegister,s,this.registerData.freeRegister)),new Be(e,0,this.registerData.freeRegister))}addMoveBlock(e,t,s){switch(e.type){case K.REG_TO_REG:this.addSpecialMov(e,t,s);break;case K.NUMBER_TO_REG:this.block.push(new $e(this.getRegisterValue(e.dst),this.registerData.zeroReg,e.src));break;case K.STACK_TO_REG:this.block.push(this.getPositiveLwInstructions(this.getRegisterValue(e.dst),-e.src,this.registerData.stackPointerRegister));break;case K.REG_TO_STACK:this.block.push(this.getPositiveSwInstructions(this.getRegisterValue(e.src),-e.dst,this.registerData.stackPointerRegister));break;case K.REG_MEM_TO_REG:this.block.push(this.getPositiveLwInstructions(this.getRegisterValue(e.dst),0,this.getRegisterValue(e.src)));break;case K.REG_TO_MEM_REG:this.block.push(this.getPositiveSwInstructions(this.getRegisterValue(e.src),0,this.getRegisterValue(e.dst)))}}prepareHeader(){this.block.push(new ze(this.registerData.zeroReg,this.registerData.zeroReg,this.registerData.zeroReg)),this.block.push(new $e(this.registerData.stackPointerRegister,this.registerData.zeroReg,this.stackPointer)),this.block.push(new $e(this.registerData.stddoutRegister,this.registerData.zeroReg,this.stddout))}run(){this.runner=new Ce(this.block,this.registerData,this.memorySize),this.runner.run()}toString_t(e=!1){let t=[];for(let s=0,i=this.block.length;s<i;s++)e?t.push(`${s}: ${this.block[s].toString()}`):t.push(this.block[s].toString());return t.join("\n")}toString(e=!1){return this.flatten().toString_t(e)}flatten_t(e,t){if(e instanceof Ee)for(let s=0,i=e.block.length;s<i;s++)this.flatten_t(e.block[s],t);else t.push(e)}flatten(){let e=new Ee(this.registerBlock,this.stddout,this.stackPointer,!1);return this.flatten_t(this,e),e}push(e){this.block.push(e)}}class Ne{toString(){return"UNDEFINED REGISTER"}}class De extends Ne{constructor(e,t,s){super(),this.dst=e,this.srcA=t,this.srcB=s}toString(){return`ADD $${this.dst} $${this.srcA} $${this.srcB}`}}class $e extends Ne{constructor(e,t,s){super(),this.t=e,this.s=t,this.immediate=s}toString(){return`ADDI $${this.t} $${this.s} ${this.immediate}`}}class Ve extends Ne{constructor(e,t){super(),this.s=e,this.t=t}toString(){return`DIV $${this.s} $${this.t}`}}class Me extends Ne{constructor(e,t){super(),this.s=e,this.t=t}toString(){return`MULT $${this.s} $${this.t}`}}class xe extends Ne{constructor(e,t,s){super(),this.s=e,this.t=t,this.i=s}toString(){return`SLL $${this.s} $${this.t} ${this.i}`}}class Oe extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SUB $${this.d} $${this.s} $${this.t}`}}class Be extends Ne{constructor(e,t,s){super(),this.t=e,this.i=t,this.s=s}toString(){return`SW $${this.t} ${this.i}($${this.s})`}}class Pe extends Ne{constructor(e,t,s){super(),this.t=e,this.i=t,this.s=s}toString(){return`LW $${this.t} ${this.i}($${this.s})`}}class ze extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`OR $${this.d} $${this.s} $${this.t}`}}class Le extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`XOR $${this.d} $${this.s} $${this.t}`}}class Ge extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.i=s}toString(){return`XORI $${this.d} $${this.s} ${this.i}`}}class Fe extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`AND $${this.d} $${this.s} $${this.t}`}}class Ue extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.i=s}toString(){return`ANDI $${this.d} $${this.s} ${this.i}`}}class We extends Ne{constructor(e){super(),this.register=e}toString(){return`JR $${this.register}`}}class He extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SLT $${this.d} $${this.s} $${this.t}`}}class Ke extends Ne{constructor(e,t,s){super(),this.s=e,this.t=t,this.label=s}toString(){return`BEQ $${this.s} $${this.t} ${this.label}`}}class je extends Ne{constructor(){super()}toString(){return"NOOP"}}class Je extends Ne{constructor(e){super(),this.label=e}toString(){return`:${this.label}`}}class qe extends Ne{constructor(e){super(),this.register=e}toString(){return`J ${this.register}`}}class Xe extends Ne{constructor(e,t){super(),this.reg=e,this.offset=t}toString(){return`PRP $${this.reg} ${this.offset}`}}class Ye extends Ne{constructor(e,t,s){super(),this.d=e,this.s=t,this.t=s}toString(){return`SLTU $${this.d} $${this.s} $${this.t}`}}class Ze{constructor(e,t={}){this.code=e,this.config={},this.defaultConfig(),this.setNewConfig(t),this.mips32Instructions=null,this.intermediaryASMInsturctions=null}setNewConfig(e){for(const[t,s]of Object.entries(e))t in this.config&&(this.config[t]=s)}defaultConfig(){this.config.registerData={zeroReg:31,stackPointerRegister:30,stddoutRegister:29,freeRegister:28,hi:27,lo:26,testRegister:25,rsp:24,ret:23,bitSplitterRegister:22},this.config.stdout=256,this.config.stackPointer=524288,this.config.memorySize=1048576}compile(){const e=new z(this.code,[],!0,this.config.stdout);let t=e.chomp();if(t.isInvalid())throw new Error(`Errors: ${e.errorsToString()}`);let s=new Ae(null);return this.intermediaryASMInsturctions=s.compileProgram(t),this.mips32Instructions=new Ee(this.intermediaryASMInsturctions,this.config.stdout,this.config.stackPointer,!0,this.config.registerData,this.config.memorySize),!0}mips32Code(){return this.mips32Instructions}intermediaryAsm(){return this.intermediaryASMInsturctions}stdoutBuffer(){return this.mips32Instructions.runner.getRawStdoutBuffer()}run(){return!!this.mips32Instructions&&(this.mips32Instructions.run(),!0)}}module.exports=t})();